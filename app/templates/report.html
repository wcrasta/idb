<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width = device-width, initial-scale=1">
<title>GGnoSWE · Report</title>
<link rel="stylesheet" type="text/css" href="../static/css/home.css">
<style type="text/css">
  body {
    background: url('../static/images/bg2.png');
  }
  h1 {
    color: black;
    text-align: center;
    margin-top: 60px;
  }
  h4 {
    color: black;
    font-size: 2em;
  }
  h3 {
    color: black;
    font-size: 0.5em;
  }
  h2 {
    color: black;
    font-size: 3em;
  }
  ul {
    color: black;
    font-size: 1.5em;
  }
  li {
    color: black;
  }
  li:hover {
    color: gray;
    text-decoration: underline;
  }
  p{
    font-size: 1.35em;
    word-wrap: break-word;
    color: black;
  }
  .row span {
    color: white;
    font-size: 1.75em;
  }
</style>
</head>

<body>

  <header>
    <!-- Starting Navigation Bar -->
    <nav class="navbar navbar-toggleable-md navbar-fixed-top" style="background-color: black; margin-top: 0;">
      <div class="container">
        <div class="navbar-header">
          <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#nav-col">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <div class="collapse navbar-collapse navbar-left" id="nav-col">
            <ul class="nav navbar-nav">
              <li class="nav-item">
                <a class="nav-link" href="/">
                  <img src="../static/images/logo.png" style="width: 100px; height: 50px; padding-top: -20px;"/>
                </a>
              </li>
              <li class="nav-item" style="padding-top: 15px;">
                <a class="nav-link" href="{{ url_for('games')}}">Games
                  <span class="sr-only">(current)</span>
                </a>
              </li>
              <li class="nav-item" style="padding-top: 15px;">
                <a class="nav-link" href="{{ url_for('platforms')}}">Platforms</a>
              </li>
              <li class="nav-item" style="padding-top: 15px;">
                <a class="nav-link" href="{{ url_for('studios')}}">Studios</a>
              </li>
              <li class="nav-item" style="padding-top: 15px;">
                <a class="nav-link" href="{{ url_for('reviews')}}">Reviews</a>
              </li>
              <li class="nav-item" style="padding-top: 15px;">
                <a class="nav-link" href="{{ url_for('about')}}">About</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </nav>

     <!-- Page Content -->
    <div class="container">
      <!-- Filtering options -->
      <div class="row">

          <div class="row">
            <div class="col-sm-12" style="border-bottom:1px solid white; padding-top: 80px">
              <h1 style="color: white;"> Report </h1>
            </div>
          </div>

          <div class="row" style="margin-top: 30px; margin-bottom: 30px; background: white; opacity: 0.8; border-radius: 15px;">
            <div class="col-sm-12">
         <h2 style="padding-top: 15px">Table of Contents</h2>
          <ul>
              <a href="#title"><li>Title</li></a>
              <a href="#intro"><li>Introduction</li></a>
              <a href="#design"><li id="title">Design</li></a>
              <a href="#tools"><li>Tools</li></a>
              <a href="#hosting"><li>Hosting</li></a>
          </ul>

          <h2 style="padding-top: 15px">Title</h2>
          <h4 style="padding-left: 12px"> Group Name: GGnoSWE</h4>
          <h4 style="padding-left: 12px"> Group Members</h4>
            <ul>
              <li>Kaivan Shah</li>
              <li>Kaden Brown</li>
              <li>Zihao Zhu</li>

              <li id="intro">Waren Cresta</li>
              <li>Warren Crasta</li>
              <li>Colin Thornton</li>
              <li>Anurag Papineni</li>
            </ul>

          <!-- INTRODUCTION-->
          <div class="row">
          <div class="col-sm-12">
          <h2 style="padding-top: 15px">Introduction</h2>
          <p>The Video Game industry is one of largest and fastest growing entertainment industries today. In recent history, video games have managed to reach comparable revenue numbers to movies, music and other forms of entertainment. In 2014, the video game industry earned approximately six times the amount of revenue that the music industry did, while growing to earn almost a third of the revenue of the film industry, and these numbers are still increasing! The allure of this growing market has spawned a multitude of game studios in the last 40 years, from massive multimedia powerhouses like EA or Activision to the smallest indie hopefuls. And all of them are constantly producing new content, with the industry cranking out over a thousand new games per year.</p>
          <p>All of this information can easily get very chaotic, and it becomes increasingly hard to search for titles you may like on a platform you own. Our goal at ggnoswe.me is to design a website which clearly allows you to view information and reviews about games as well as their developers and platforms. With this tool, a user will be able to browse our website and get a good understanding of what the best games for a particular platform are, what games a studio has developed, and what games they may like based on ratings and reviews.</p>
          <p>There are several scenarios where this could prove useful. If a user was trying to get into “The Legend of Zelda” for the first time they could simply search for that name and easily figure out which game(s) from the series they wanted to start with based on ratings and reviews, and what platforms they have access to.</p>
          <p>Another example user might like “Final Fantasy” as a series, but want to find something else by the same studio with a similar feel on a different platform since that series is mainly restricted to Playstation. As before they could simply navigate to a game in the series and go to the studio.
          </p><p id="design">From here they can see a list of published games and look through them to see if any match what they want. For example, if they were looking for 3DS games they may be directed to titles like “Bravely Default” or “Dragonquest” which are more readily available on Nintendo platforms but developed by the same Studio with the same general aesthetic.</p>
          <p>Overall this website aims to be a tool which makes information gathering about video games easier users so they can make more effective decisions on choosing what games to play.  </p>
          </div>
        </div>

          <!-- DESIGN -->
          <h2 style="padding-top: 15px">Design</h2>

          <h4>Apiary API:</h4>
          <p>The API we designed through apiary works in a similar fashion for each model. For instance the games model has two different calls that can be made to the API: List All Games and List Specific Game. A user of the API can call list all games that will return to them a list of JSONs that contain two keys id and name that users may store on their own machines.</p>

          <figure>
           <img class="center-block" float="left" src="../static/images/design_1.png"/>
           <figcaption style="color: black; text-align: center; font-size: 1.2em">Fig1. - Example of List all games JSON.</figcaption>
          </figure>

            <div style="float:none; padding-top: 20px;">
              <p> With this information the user is now able to make a call to the List Specific Game API call using the value of id. This call will return to a single JSON that contains the information for game such as id, name, summary, genre, rating, ect.</p>
            </div>

          <figure>
           <img class="center-block" float="left" src="../static/images/design_2.png"/>
           <figcaption style="color: black; text-align: center; font-size: 1.2em">Fig2. - Example of JSON for a specific game.</figcaption>
          </figure>

            <div style="float:none; padding-top: 20px;">
              <p> This process remains the same for Platform, Studio as well as Reviews allowing the user to find information for the specific topic they want in each model rather than sending them all of the information in the database.</p>
            </div>

            <h4>IGDB API Calls:</h4>
            <p> The API we are accessing through igdb.com returned a list of JSONs that contains the many attributes of a game such as name, created_at and url. It also comes with information such as hypes and time_to_beat which are not necessary for our project and will be filtered out before we put it into our database. We are currently scraping the api by first creating a header dictionary that contains our api key that will later be used in the url of the api request.  Then we continuously loop in order to pull all of the info from the api and break when we receive multiple error codes indicating the end to exit the loop.</p>

          <figure>
           <img class="center-block" float="left" src="../static/images/design_3.png"/>
           <figcaption style="color: black; text-align: center; font-size: 1.2em">Fig3. - Conditions for leaving the loop.</figcaption>
          </figure>

            <div style="float:none; padding-top: 20px;">
              <p> Inside of the loop in order speed up the process we concatenate our current index into the dataset with all entries up to index+1000 separated by a comma.</p>
            </div>

          <figure>
           <img class="center-block" float="left" src="../static/images/design_4.png"/>
           <figcaption id="tools" style="color: white; text-align: center; font-size: 1.2em">Fig4. - Speeding up API requests by altering URL.</figcaption>
          </figure>

            <div style="float:none; padding-top: 20px;">
              <p> This allows for a single call to return multiple JSONs with a single api call. From there we parse the JSONs so that they may be added to the output list.</p>
            </div>

            <!-- TOOLS-->
          <h2 style="padding-top: 15px">Tools</h2>
          <h4>Front-End:</h4>
          <p>The front-end technologies we will be using include CSS, Bootstrap, HTML, Javascript and ReactJS. Cascading style sheets are used to cleanly handle formatting, placement, and fonts. Bootstrap is a front end framework used to make pages dynamic and responsive. It makes organization easier. Javascript is a front end language used to do logic in the front end such as handle user inputs and trigger events. ReactJS is a JavaScript library that gives the ability to create very dynamic, interactive webpages that give a great user experience. It will be used for sorting, filtering, routing and used for its ability to dynamically change the DOM in our html. Another tool that was used was Bootstrap, a css and javascript component that was used to make our website look presentable. The tool used to embed the company image and game image is simple css and bootstrap css that makes the image responsive and change the size of the image to fit into the div correctly and nicely.</p>

          <h4>Back-End:</h4>
          <p> For the backend of our application, we focused mainly on using the tools Flask paired with Jinja2 for rendering and SQLAlchemy for populating our grids and model instances with data. While it was only necessary to populate 3 instances (rows) for each models, we decided to scrape data from the API we’re using (https://igdb.github.io/api/)  and populated a local database using SQLAlchemy. Doing so allowed us to easily access the data and create dynamically linked pages with more information and embedded images along with creating paginations. We chose this route over hard-coding and parsing made-up JSON files because we will eventually implement a database and doing so will save work in the long run.</p>

          <h4>Embedded Media Services</h4>

          <p>For our models, we embedded various pictures and logos that associate with the respective models. For instance, Game models had a picture of the game displayed if it exists, Platform models had a picture of the console if it exists and so on. These were implemented using html and the image tag, passing in the link to the image as the src. For videos of reviews and games if they existed, we used the iframe tag passing in the width and the desired lengths. For src, we passed in the link to the video if it existed.</p>

          <h4>Scraping Data:</h4>

          <p>In order to scrape the data, we first registered an API key with IGDB on http://igdb.github.io/api/. After following through their documentations, we learned the various options we had and the information each call would output. The four models we focused on were Game, Companies, Reviews and Platforms. We established these four as our primary models. We then created one general script trying to scrape data for each of our models. To accomplish this, we used the Python libraries requests, json and sys. Requests were used to connect to the API and gather the data and we save the data as a json file and we use sys to parse the various inputs that the script takes to populate a given model. Sample call is as shown in the figure:</p>

          <p>In order to scrape the data, we first registered an API key with IGDB on http://igdb.github.io/api/. After following through their documentations, we learned the various options we had and the information each call would output. We then created one general script trying to scrape data for each of our models. To accomplish this, we used the Python libraries requests, JSON and sys. Requests were used to connect to the API and gather the data. From there, we saved the data as a JSON file and we used sys to parse the various inputs that the script takes to populate a given model. Sample call is as shown in the figure:</p>


          <figure>
           <img class="center-block" float="left" src="../static/images/tools_1.png" style="height: 300px; width: 550px;"/>
           <figcaption style="color: black; text-align: center; font-size: 1.2em; ">Fig 1. scraping data</figcaption>
          </figure>

          <p>In the JSON files we save, they contain the different information regarding the games, platforms, reviews and game companies as shown as follows: </p>

          <figure>
           <img class="center-block" float="left" src="../static/images/tools_2.png" style="height: 250px; width: 600px;"/>
           <figcaption style="color: black; text-align: center; font-size: 1.2em">Fig 2. JSON data</figcaption>
          </figure>

          <p>With this information, we were able to populate our database as described in the following sections.</p>

          <h4>Models:</h4>
          <p>A major part of ORM(object relational mapping) is models. In our application, we defined four models: game, platform, studio and reviews. In models.py, we created a model for each of our four classes and defined the attributes we wanted them to have. Since models.py works closely with SQLAlchemy, for each attribute of each model, we defined the expected type for the attribute. In cases in which there’s a one to many or many to one relationship, we employed the method db.relationship() with parameters backref and lazy=”dynamic” to set up the relationship so that we can access the respective model. Backref allows the objects to link to each other while lazy=”dynamic” allows us to display the query results when we render it in Jinja2. In other words, backref is a simple way to declare some new property of the class you’re linking a model to. Whereas lazy defines when SQLAlchemy will load the data from the database you create. Setting up the models.py allowed us to create objects for each model and be able to use data in a declarative way as we did in __init__.py. Having defined the relationships, it made it easier for us to get the attributes a certain object was connected it. We overwrote __init__ for each model and then we declared them as we made our objects. We used assertions throughout the init methods to make sure that the data being passed in are what we were expecting. </p>

          <h4>Database:</h4>
          <p>We used SQLAlchemy with our Flask application as a means of easily storing data and accessing them when needed. We first configured our application to use the local database in __init__.py as show below:<p>

          <figure>
           <img class="center-block" float="left" src="../static/images/tools_3.png" style="height: 250px; width: 550px;"/>
           <figcaption style="color: black; text-align: center; font-size: 1.2em">Fig 3. Initialize database</figcaption>
          </figure>

          <p>Then to initialize the database, we entered the Python interactive mode and created a session for the database and called “db.create_all()”. In order to populate our database as quickly and efficiently as possible, we created a script called populateDb.py that we used to parse the JSON files we scraped as detailed above and inserted the various object models into the database. For each model, we constructed the appropriate object and initialized the information and then added the object to our database using db.session.add(). Then we committed the change if no errors occurred.</p>

          <h4>__init__.py</h4>
          <p>__init__.py is the main file for our application. __init__.py is our file from which we run the application on the server. In it, we defined the different routes to the html/css files in templates and we configured basic information for our application such as the database path as shown:</p>

          <figure>
           <img class="center-block" float="left" src="../static/images/tools_4.png" style="width: 550px;"/>
           <figcaption style="color: black; text-align: center; font-size: 1.2em">Fig 4. Routing</figcaption>
          </figure>


          <p>For pagination and populating the pages with our data, we accessed the database for the respective model and rendered the template passing in the list of objects. To easily accomplish this, we employed a flask library called flask-paginate that handled most of the work for pagination. Then we altered our html files to employ Jinja2 as a way to dynamically generate the data and provide pages limited by the number of items we want for each page. While Jinja2 may be considered front-end, since it comes with Flask, the back-end developers used it to render the various pages and their elements.</p>

          <p id="hosting">For pagination and populating the pages with our data, we accessed the database for the respective model and rendered the template passing in the list of objects. To easily accomplish this, we employed a flask library called flask-paginate that handled most of the work for pagination. Then we altered our html files to employ Jinja2 as a way to dynamically generate the data and provide pages limited by the number of items we want for each page.</p>


          <!--HOSTING-->
          <h2 style="padding-top: 15px">Hosting</h2>
          <p>To set up an AWS server that hosts a Flask application:</p>

          <h4>I. Create a Virtual Private Cloud (VPC)</h4>
          <ol style="font-size: 1.3em; color:white">
            <li>Create an AWS account and log in to the console.
            <li>From the Services tab, select VPC. A Virtual Private Cloud (VPC) determines who gets to access your website.
            <li>Click Start VPC Wizard > VPC with a Single Public Subnet. Keep most of the defaults, but give a value to VPC name. Under Service Endpoints, click Add Endpoint. In the Subnet field, select Public Subnet. Create the VPC.
          </ol>

          <h4>II. Create an EC2 instance</h4>

          <ol style="font-size: 1.3em; color:white">
            <li>Once the VPC has been created, from the Services tab, select EC2. Under the Create Instance heading, click Launch Instance. Select the Free Tier Eligible Ubuntu Server.
              <figure>
               <img class="center-block" float="left" src="../static/images/hosting_1.png" style="width: 550px;"/>
               <figcaption style="color: black; text-align: center; font-size: 0.9em">Figure 1: Free Tier Eligible Ubuntu Server</figcaption>
              </figure>
              For the Instance Type, select the General Purpose, Free Tier Eligible instance type. Click Next.
            </li>

            <li>On Step 3: Configure Instance Details, change Auto-assign Public IP to Enable.
            <li>In the EC2 configuration settings, skip to Step 7: Review Instance Launch. Under the Security Groups heading, click Edit security groups > Add Rule > Type: HTTP > Source: Anywhere. Then click Review and Launch.
              <figure>
               <img class="center-block" float="left" src="../static/images/hosting_2.png" style="width: 550px;"/>
               <figcaption style="color: black; text-align: center; font-size: 0.9em">Figure 2: Review Instance Launch Settings</figcaption>
              </figure>
            </li>
            <li>When you launch your instance, you will need to create a new key/pair. Give it a name, and download the key/pair file. Make sure you know where you downloaded the file; you will need it to SSH into your Linux box.

            <li>To connect to your instance, select it from the EC2 Management page and click Connect. The following message will pop up. Follow the instructions and you’ll be able to connect to your instance.
              <figure>
                 <img class="center-block" float="left" src="../static/images/hosting_3.png" style="width: 550px;"/>
                 <figcaption style="color: black; text-align: center; font-size: 0.9em">Figure 3: Instructions to access your EC2 instance</figcaption>
              </figure>
              Once you’ve connected to your Linux box, your terminal should look like this:
              <figure>
                 <img class="center-block" float="left" src="../static/images/hosting_4.png" style="width: 550px;"/>
                 <figcaption style="color: black; text-align: center; font-size: 0.9em">Figure 4: Connecting to an EC2 instance</figcaption>
              </figure>
            </li>

          </ol>

        <h4>III. Installing Apache on the EC2 Instance</h4>

        <ol style="font-size: 1.3em; color:white">
            <li>In order to correctly host a Flask application on your EC2 instance, you need web server software, which is where Apache comes in. To install Apache run the following commands in your terminal:
              <code>sudo apt-get install apache2
              <br>sudo apt-get update
              <br>sudo apt-get install libapache2-mod-wsgi<br></code>

              To verify that Apache has been installed correctly, enter the IP Address of your EC2 instance in a web browser. To find the IP Address, click on your instance in the EC2 Management Console and copy the value given as the IPv4 Public IP. You should see a page like this in your web browser:
              <figure>
                 <img class="center-block" float="left" src="../static/images/hosting_6.png" style="height: 350px"/>
                 <figcaption style="color: black; text-align: center; font-size: 0.9em">Figure 5: Sample Ubuntu Default Page</figcaption>
              </figure>
            </li>
          </ol>

          <h4>IV. Installing and Deploying the Flask Application</h4>
          <ol style="font-size: 1.3em; color:white">
            <li>Once you’ve verified that Apache has been correctly installed, install Flask with the following commands:<br>
              <code>sudo apt-get install python-flask
              <br>sudo apt-get upgrade<br></code>

            <li>n the /var/www directory, create the following project structure:
               <figure>
                 <img class="center-block" float="left" src="../static/images/hosting_8.png"/>
                 <figcaption style="color: black; text-align: center; font-size: 0.9em">Figure 7</figcaption>
              </figure>

                NOTE: From here on, replace any instances of GGnoSWE with the desired name of your application.<br>
              GnoSWEApp is where your Flask application code should live. Copy any Flask application code from your local machine to this directory.
            <li>Install any libraries/modules that your application needs on the server. For example,<br>
              <code>sudo apt-get install python-pip<br>
              sudo pip install Flask-SQLAlchemy<br>
              </code>
          </ol>

          <h4>V. Configuring Apache to point to your Flask Application</h4>
          <ol style="font-size: 1.3em; color:white">
            <li>Create a file in /etc/apache2/sites-available/ named GGnoSWEApp.conf with the following contents, replacing XXXXXXXX with the IP Address of your EC2 instance and the ServerAdmin’s e-mail with your email:
              <figure>
                 <img class="center-block" float="left" src="../static/images/hosting_9.png"/>
                 <figcaption style="color: black; text-align: center; font-size: 0.9em">Figure 8</figcaption>
              </figure>
              Run the following commands to configure/restart Apache:<br>
              <code>sudo a2enmod wsgi<br>
                    sudo apachectl restart<br>
                    sudo a2ensite GGnoSWEApp<br>
                    service apache2 reload<br>
                    sudo /etc/init.d/apache2 reload<br>
              </code>
            </li>
            <li>
              To tell Apache how to run Flask, create a file named FlaskApps.wsgi in the /var/www/FlaskApps/ directory and enter the following code, replacing home with the name of the Python file that runs your Flask application:<br>
              <code>#! /usr/bin/python<br>
                    import sys<br>
                    import logging<br>
                    logging.basicConfig(stream=sys.stderr)<br>
                    sys.path.insert(0,"/var/www/FlaskApps/GGnoSWEApp/")<br>
                    <br>
                    # home points to the home.py file<br>
                    from home import app as application<br>
                    application.secret_key = "somesecretsessionkey"<br>
              </code>
              Restart the Apache server with the following 2 commands:<br>
              <code>
                sudo service apache2 restart<br>
                sudo /etc/init.d/apache2 reload<br>
              </code>
            </li>
            <li>
              Type the IP Address of your EC2 instance in your web browser again and you should be able to see your Flask application on the Internet! As an example:
              <figure>
                 <img class="center-block" float="left" src="../static/images/hosting_13.png" style="height: 450px; width: 700px;"/>
                 <figcaption style="color: black; text-align: center; font-size: 0.9em">Figure 9: Example of a deployed Flask application</figcaption>
              </figure>
            </li>
            <li>
              Every time you make changes to the Flask application on your server, remember to restart Apache afterwards. Simply run the following command after each change:<br>
              <code>
                sudo service apache2 restart<br>
              </code>
              You have now deployed your Flask application on an EC2 instance with the help of an Apache web server.
            </li>
          </ol>
        </div>
      </div>
      </div>
    </div>
  </header>
</body>